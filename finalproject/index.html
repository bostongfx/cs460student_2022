<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  

        background-image: url(background.jpeg);
        background-repeat: no-repeat;
        background-size: 100% 100%;
      }
    </style>
    <audio src="Dragonball.mp3" controls>
      <p>If you are reading this, it is because your browser does not support the audio element.</p>
      </audio>
    <script src="https://threejs.org/build/three.min.js" type="text/javascript"></script>
    <script src="https://threejs.org/examples/js/controls/TrackballControls.js" type="text/javascript"></script>
    <script src="https://threejs.org/examples/js/effects/AnaglyphEffect.js" type="text/javascript"></script>

    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js" type="text/javascript"></script>

    <script src="ParticleBasicMaterial.js" type="text/javascript"></script>

    <script src="robot.js" type="text/javascript"></script>

    <script src="helper.js" type="text/javascript"></script>

    <script src="explosion.js" type="text/javascript"></script>

    <script>
      

      var scene, camera, renderer, effect, ambientLight, light, controls;
      var floor;
      var parts = [];
      var mainTime = 0;
      var mainTimeTotalCount = 0;
      var r1_flying = false;
      var r1_flyingdown = false;
      var main_animation = false;

      window.onload = function() {


        scene = new THREE.Scene();

        var fov = 75;
        var ratio = window.innerWidth / window.innerHeight;
        var zNear = 1;
        var zFar = 10000;
        camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
        camera.position.set( 0, 0, 500);

        renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );
        
        effect = new THREE.AnaglyphEffect( renderer );
        effect.setSize( window.innerWidth, window.innerHeight );

        ambientLight = new THREE.AmbientLight();
        scene.add( ambientLight );

        light = new THREE.DirectionalLight( 0xffffff, 5.0 );
        light.position.set( 10, 100, 10 );
        scene.add( light );


        // var floorTexture = new THREE.TextureLoader().load( 'background.jpeg' );
        // var floorGeometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
        // var floorMaterial = new THREE.MeshBasicMaterial( {
        //   map: floorTexture,
        //   side: THREE.DoubleSide
        // } );
        // floor = new THREE.Mesh( floorGeometry, floorMaterial );
        // floor.position.y = -100;
        // floor.rotateX(Math.PI/2);
        // scene.add( floor );

        all_robots = [];
        skillObjects = [];

        r = new Robot(0, -131, 0);
        r.show(scene);

        all_robots.push(r);

        //left side
        r0 = new Robot(-400, -131, 0);
        var tempRotateDegRadians = 90*Math.PI/180;
        r0.root.rotateY(tempRotateDegRadians);
        r0.facing_angle = tempRotateDegRadians * (180/Math.PI);
        r0.show(scene);
        all_robots.push(r0);

        //right side
        r1 = new Robot(400, -131, 0);
        var tempRotateDegRadians = 270*Math.PI/180;
        r1.root.rotateY(tempRotateDegRadians);
        r1.facing_angle = tempRotateDegRadians * (180/Math.PI);
        r1.show(scene);
        all_robots.push(r1);


        controller = {
          anaglyph: false,
          dance: function() {

            // start the music
            /*var music = document.getElementById('music');
            music.autoplay = true;
            music.load();
            
            var video = document.getElementById('video');
            var texture = new THREE.VideoTexture( video );
            floor.material.map = texture;
            video.play();*/

            for (var r in all_robots) {
              r = all_robots[r];
              r.dance();
            }
          },
          AllspiritBomb: function() {
            for (var r in all_robots) {
              r = all_robots[r];
              r.hands_up();
            }
          },
          AllshootBeam: function() {
            for (var r in all_robots) {
              r = all_robots[r];
              r.shoot_beam();
            }
          },
          walk: function() {

            for (var r in all_robots) {
              r = all_robots[r];
              r.walk();
            }
          },
          StartAnimation: function() {
            main_animation = true;
          },
          Reset: function() {
            main_animation = false;
            r1_flying = false;
            r1_flyingdown = false; 
            mainTime = 0;
            mainTimeTotalCount = -1;
            main_animation = false;

            //all_robots = [];
            skillObjects = [];

            r = new Robot(0, -131, 0);
            r.show(scene);

            all_robots.push(r);

            //left side
            r0 = new Robot(-400, -131, 0);
            var tempRotateDegRadians = 90*Math.PI/180;
            r0.root.rotateY(tempRotateDegRadians);
            r0.facing_angle = tempRotateDegRadians * (180/Math.PI);
            r0.show(scene);
            all_robots.push(r0);
          }
        }


        var gui = new dat.GUI();
        var rendering = gui.addFolder( "Rendering" );
        rendering.add( controller, 'anaglyph' );
        rendering.open();
        var moving = gui.addFolder( "Movement" );
        moving.add( r.root.position, "x", -1000, 1000 ).listen();
        moving.add( r.root.position, "y", -1000, 1000 ).listen();
        moving.add( r.root.position, "z", -1000, 1000 ).listen();
        moving.add( r, "raise_left_arm" );
        moving.add( r, "lower_left_arm" );
        moving.add( r, "hands_up" );
        moving.add( r, "shoot_beam" );
        moving.add( r, "kick" );
        //moving.add( r, "walk" );
        //moving.add( r, "walk2" );
        moving.add( controller, "dance" );
        moving.add( controller, "walk" );
        moving.add( controller, "AllspiritBomb" );
        moving.add( controller, "AllshootBeam" );
        //moving.open();

        var action = gui.addFolder( "Main" );
        action.add( controller, "StartAnimation" );
        action.add( controller, "Reset" );
        action.open();



        controls = new THREE.TrackballControls( camera, renderer.domElement );

        //TODO: Bonus 1, 1 obj, 2 point light
        //global variable object list array
        objects_list = [];

        var objTexture = new THREE.TextureLoader().load( 'board.jpg' );
        var objGeometry = new THREE.BoxBufferGeometry( 100, -100, 100 );
        var objMaterial = new THREE.MeshBasicMaterial( {
          map: objTexture
        } );

        var object1 = new THREE.Mesh(objGeometry, objMaterial);
        object1.position.x = 300;
        object1.position.y = -45;
        object1.position.z = 300;
        objects_list.push(object1);
        // scene.add(object1);

        var object2 = new THREE.Mesh(objGeometry, objMaterial);
        object2.position.x = -300;
        object2.position.y = -45;
        object2.position.z = -300;
        objects_list.push(object2);
        // scene.add(object2);

        pointLight1 = new THREE.PointLight( 0xff0000, 1, 100 );
        pointLight1.position.set( 300, 100, 300 );
        scene.add( pointLight1 );

        pointLight2 = new THREE.PointLight( 0x00ff00, 1, 100 );
        pointLight2.position.set( -300, 100, -300 );
        scene.add( pointLight2 );
        
        //Bonus 1

        //assistance
        hasBall = false;
        hasBeam = false;

        animate();


      };

      window.onclick = function(e) {
          if (!e.shiftKey) {

            e.preventDefault();
            return false;
          }

          //var explode = new Explosion(e.clientX, e.clientY);
          //parts.push(explode);

          pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

          vp_coords = new THREE.Vector2( ( pixel_coords.x / window.innerWidth ) * 2 - 1,
                                        -( pixel_coords.y / window.innerHeight ) * 2 + 1);

          vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

          raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(vp_coords_near, camera);
          intersects = raycaster.intersectObject(floor);

          if (intersects.length > 0) {

              // r.root.position.set(intersects[0].point.x, 
              //                     intersects[0].point.y + 70,
              //                     intersects[0].point.z)

              r = new Robot(intersects[0].point.x, 
                                  intersects[0].point.y + 70,
                                  intersects[0].point.z);
              r.show(scene);
              //r.root.rotateY(Math.PI);
              //TODO
              var tempRotateDegRadians = randomVal(0.0, Math.PI*2);
              //var tempRotateDegRadians = Math.PI/2+Math.PI;
              //var tempRotateDegRadians = 270*Math.PI/180;
              r.root.rotateY(tempRotateDegRadians);
              r.facing_angle = tempRotateDegRadians * (180/Math.PI);
              //console.log(tempRotateDegRadians * (180/Math.PI));

              all_robots.push(r);

          }

      };

      function randomVal(min, max) {
        if(min > max) {
          throw new Error('Minimum value should be smaller than maximum value.');
        }
        var range = max - min;
        return min + range * Math.random();
      };

      function removeItemFromArray(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
          arr.splice(index, 1);
        }
        return arr;
      };

      function check_beingHit_byBeam(robot) {
        for (var temp_i = 0; temp_i < all_robots.length; temp_i++) {
          if (robot != all_robots[temp_i]) {
            var tempR = all_robots[temp_i];
            //console.log(robot.root.position.x - tempR.root.position.x);
            var tempR2 = robot.cloneRobot();

            for (var temp_j = 0; temp_j < 40; temp_j++) {
              if (Math.abs(tempR2.root.position.x - tempR.root.position.x) <= 20 &&
                  Math.abs(tempR2.root.position.y - tempR.root.position.y) <= 20 &&
                  Math.abs(tempR2.root.position.z - tempR.root.position.z) <= 20) {
                    //console.log("returns x: " +Math.abs(tempR2.root.position.x - tempR.root.position.x)+
                    //            ",returns y: " +Math.abs(tempR2.root.position.y - tempR.root.position.y)+
                    //            ",returns z: " +Math.abs(tempR2.root.position.z - tempR.root.position.z));
                  
                  
                  //
                  removeItemFromArray(all_robots, tempR);
                  var explode = new Explosion(tempR.root.position.x, tempR.root.position.y, tempR.root.position.z);
                  parts.push(explode);
                  tempR.removeFromShow(scene);
                  return true;
              }
              tempR2.root.translateZ(15);
            }
          }
        }
        return false;
      };

      function cast_beam(robot) {
        var movement1 = (robot.movement == 'shoot beam raise right hand over beam ready')
        var movement2 = ((robot.movement == 'shoot beam raise right hand over beam done'))
        //if (robot.check_hands_up_then_cast_ball && !hasBall) {
        if (movement1 && !robot.hasBeam) {
          //console.log("B");
          //console.log(hasBall);
          robot.hasBeam = true;
          var radius = 15;
          var cylinderGeometry = new THREE.CylinderBufferGeometry(
            2, // radiusTop
            2, // radiusBottom
            40, // height
            8, // radiusSegments
            5 * 3, // heightSegments
            false // openEnded
          );
          var cylinderMaterial = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
          var cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
          robot.setCylinderMesh(cylinder);
          skillObjects.push(robot.sphereMesh);
          cylinder.rotateX(90*(Math.PI/180.0));
          //cylinder.rotateZ(robot.facingOfRobot()*(Math.PI/180.0));
          cylinder.rotateZ(-robot.facingOfRobot()*(Math.PI/180.0));

          cylinder.position.x = robot.root.position.x*1 + robot.neck.position.x + robot.right_upperarm.position.x + robot.right_lowerarm.position.x + robot.right_hand.position.x;
          cylinder.position.y = robot.root.position.y*1 + robot.neck.position.y + robot.right_upperarm.position.y + robot.right_lowerarm.position.y + robot.right_hand.position.y;
          cylinder.position.z = robot.root.position.z*1 + robot.neck.position.z + 0;

          //cylinder.position.x = robot.root.position.x*1;
          //cylinder.position.y = robot.root.position.y*1;
          //cylinder.position.z = robot.root.position.z*1;
          if (robot.facingOfRobot() > 179) {
            cylinder.position.x = -cylinder.position.x-25;//+25
          //cylinder.position.y = -cylinder.position.y;
          //cylinder.position.z = -cylinder.position.z;
          }
          cylinder.rotateY(robot.facingOfRobot()*(Math.PI/180));
          
          //TODO rotate, need better one
          if (robot.facingOfRobot() > 179) {
            cylinder.position.x = cylinder.position.x * -1;
          }
          scene.add( cylinder );
        } else if (movement1) {
          robot.increaseCylinderScale();
          robot.sphereMesh.scale.setScalar(robot.sphereMeshScale);
          robot.sphereMesh.translateY(12.5);
          if (robot.time < 3.0) {
            check_beingHit_byBeam(robot);
            //robot.sphereMesh.translateZ(2.0);
            //robot.sphereMesh.translateY(2.0);
            var tempRTop = robot.sphereMesh.geometry.parameters.radiusTop;
            var tempRBottom = robot.sphereMesh.geometry.parameters.radiusBottom;
            robot.sphereMesh.geometry.dispose();
            robot.sphereMesh.geometry = new THREE.CylinderBufferGeometry(tempRTop*0.80, tempRBottom*0.80, 40, 8);
            //robot.sphereMesh.geometry.parameters.radiusTop = robot.sphereMesh.geometry.parameters.radiusTop * 0.9;
            //robot.sphereMesh.geometry.parameters.radiusBottom = robot.sphereMesh.geometry.parameters.radiusBottom * 0.9;
          }
          else {
            //robot.removeSceneObj(robot.sphereMesh);
            robot.hasBeam = false;
            scene.remove( robot.sphereMesh );
            robot.movement = 'idle';
          }
        } else if (movement2) {
          robot.increaseTime();
          if (robot.time < 3.0) {
            check_beingHit_byBeam(robot);
            //robot.sphereMesh.translateZ(2.0);
            //robot.sphereMesh.translateY(2.0);
            var tempRTop = robot.sphereMesh.geometry.parameters.radiusTop;
            var tempRBottom = robot.sphereMesh.geometry.parameters.radiusBottom;
            robot.sphereMesh.geometry.dispose();
            robot.sphereMesh.geometry = new THREE.CylinderBufferGeometry(tempRTop*0.80, tempRBottom*0.80, 40, 8);
            //robot.sphereMesh.geometry.parameters.radiusTop = robot.sphereMesh.geometry.parameters.radiusTop * 0.9;
            //robot.sphereMesh.geometry.parameters.radiusBottom = robot.sphereMesh.geometry.parameters.radiusBottom * 0.9;
          }
          else {
            //robot.removeSceneObj(robot.sphereMesh);
            robot.hasBeam = false;
            removeItemFromArray(skillObjects, robot.sphereMesh);
            scene.remove( robot.sphereMesh );
            robot.movement = 'idle';
          }
        }
        
      };

      function check_beingHit_byBall(sphereMesh) {
        var tempRemoveList = [];
        for (var temp_i = 0; temp_i < all_robots.length; temp_i++) {
          //if (robot != all_robots[temp_i]) {
            var tempR = all_robots[temp_i];

                    //console.log(temp_i+"returns x: " +Math.abs(sphereMesh.position.x - tempR.root.position.x)+
                    //            ",returns y: " +Math.abs(sphereMesh.position.y - tempR.root.position.y)+
                    //            ",returns z: " +Math.abs(sphereMesh.position.z - tempR.root.position.z));
            
              if (Math.abs(sphereMesh.position.x - tempR.root.position.x) <= 120 &&
                  Math.abs(sphereMesh.position.y - tempR.root.position.y) <= 150 &&
                  Math.abs(sphereMesh.position.z - tempR.root.position.z) <= 120) {
                    //console.log("returns x: " +Math.abs(tempR2.root.position.x - tempR.root.position.x)+
                    //            ",returns y: " +Math.abs(tempR2.root.position.y - tempR.root.position.y)+
                    //            ",returns z: " +Math.abs(tempR2.root.position.z - tempR.root.position.z));
                  
                  
                  //
                  //removeItemFromArray(all_robots, tempR);
                  var explode = new Explosion(tempR.root.position.x, tempR.root.position.y, tempR.root.position.z);
                  parts.push(explode);
                  //tempR.removeFromShow(scene);
                  tempRemoveList.push(tempR);
                  //return true;
              
              
            //}
          }
        }
        for (var temp_i = 0; temp_i < tempRemoveList.length; temp_i++) {
          tempRemoveList[temp_i].removeFromShow(scene);
          removeItemFromArray(all_robots, tempRemoveList[temp_i]);
        }
        tempRemoveList = null;
        return false;
      };

      function cast_ball(robot, ty, tz, t_time) {
        //console.log(robot.check_hands_up_then_cast_ball);
        var movement1 = (robot.movement == 'hands up')
        var movement2 = ((robot.movement == 'hands up over done') || (robot.movement == 'hands up over'))
        //if (robot.check_hands_up_then_cast_ball && !hasBall) {
        if (movement1 && !robot.hasBall) {
          //console.log("B");
          //console.log(hasBall);
          robot.hasBall = true;
          robot.setSphereMesh(1);
          scene.add( robot.sphereMesh );
          skillObjects.push(robot.sphereMesh);
        } else if (movement1) {

          robot.increaseSphereScale();
          //robot.sphereMesh.scale.setScalar(robot.sphereMeshScale);
          //robot.sphereMesh.translateY(1.5);
        } else if (movement2) {
          robot.increaseTime();
          if (robot.time < t_time) {
            //robot.sphereMesh.translateZ(3.0);
            //robot.sphereMesh.translateY(-0.5);
            robot.sphereMesh.translateZ(tz);
            robot.sphereMesh.translateY(ty);
          }
          else {
            //robot.removeSceneObj(robot.sphereMesh);
            robot.hasBall = false;
            var explode = new Explosion(robot.sphereMesh.position.x, robot.sphereMesh.position.y, robot.sphereMesh.position.z);
            parts.push(explode);
            check_beingHit_byBall(robot.sphereMesh);
            removeItemFromArray(skillObjects, robot.sphereMesh);
            scene.remove( robot.sphereMesh );
            robot.movement = 'idle';
          }
        }
      };

      function robot_fly(robot, height) {
        robot.root.translateY(height);
      };

      function animate() {
        //cast_ball(r);
        //cast_beam(r);

        requestAnimationFrame( animate );

        for (r in all_robots) {
          r = all_robots[r];
          if (r == r1) {
            cast_ball(r, -6.0, 12.0, 7.0);
          } else { cast_ball(r, -0.5, 3.0, 15.0); }
          cast_beam(r);
          //robot_fly(r, 0.5);
          r.onAnimate();  
          //console.log("robot x:"+r.root.position.x);
          //console.log("robot z:"+r.root.position.z);
        }

        controls.update();

        if (main_animation) {
          mainTime += 1;
          if (mainTime % 30 == 0) {
            console.log(mainTime);
            mainTime = 0;
            if (mainTimeTotalCount == 5-5) {
              r0.movement = 'shoot beam raise right hand';
              r1_flying = true;
            } else if (mainTimeTotalCount == 7-5) {
              r1_flying = false;
              r1.movement = 'hands up';
            } else if (mainTimeTotalCount == 11-5) {
              r1_flyingdown = true; 
            } else if (mainTimeTotalCount == 13-5) {
              r1_flyingdown = false; 
              mainTime = 0;
              mainTimeTotalCount = -1;
              main_animation = false;
            }
            mainTimeTotalCount += 1;
          }
          if (r1_flying == true) {
            robot_fly(r1, 5);
          }
          if (r1_flyingdown == true) {
            robot_fly(r1, -5);
          }
        }

        var pCount = parts.length;
        /*if (pCount > 0) {
        //console.log(parts[0]);
        parts[0].update();
        }*/
        while(pCount > 0) {
          parts[pCount-1].update();
          pCount--;
        }

        if (controller.anaglyph) {
            renderer.setClearAlpha(1);
            effect.render( scene, camera );
        } else {
            renderer.setClearAlpha(0);
            renderer.render( scene, camera );
        }
        

      };

    </script>
  </head>
  <body>
    <div style="visibility:hidden">

    </div>
  </body>
</html>